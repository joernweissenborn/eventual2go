
/*
 * generated by event_generator
 *
 * DO NOT EDIT
 */

package typed_events

import "github.com/joernweissenborn/eventual2go"



type StringCompleter struct {
	*eventual2go.Completer
}

func NewStringCompleter() *StringCompleter {
	return &StringCompleter{eventual2go.NewCompleter()}
}

func (c *StringCompleter) Complete(d string) {
	c.Completer.Complete(d)
}

func (c *StringCompleter) Future() *StringFuture {
	return &StringFuture{c.Completer.Future()}
}

type StringFuture struct {
	*eventual2go.Future
}

type StringCompletionHandler func(string) string

func (ch StringCompletionHandler) toCompletionHandler() eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		return ch(d.(string))
	}
}

func (f *StringFuture) Then(ch StringCompletionHandler) *StringFuture {
	return &StringFuture{f.Future.Then(ch.toCompletionHandler())}
}

func (f *StringFuture) AsChan() chan string {
	c := make(chan string, 1)
	cmpl := func(d chan string) StringCompletionHandler {
		return func(e string) string {
			d <- e
			close(d)
			return e
		}
	}
	ecmpl := func(d chan string) eventual2go.ErrorHandler {
		return func(error) (eventual2go.Data, error) {
			close(d)
			return nil, nil
		}
	}
	f.Then(cmpl(c))
	f.Err(ecmpl(c))
	return c
}

type StringStreamController struct {
	*eventual2go.StreamController
}

func NewStringStreamController() *StringStreamController {
	return &StringStreamController{eventual2go.NewStreamController()}
}

func (sc *StringStreamController) Add(d string) {
	sc.StreamController.Add(d)
}

func (sc *StringStreamController) Join(s *StringStream) {
	sc.StreamController.Join(s.Stream)
}

func (sc *StringStreamController) JoinFuture(f *StringFuture) {
	sc.StreamController.JoinFuture(f.Future)
}

func (sc *StringStreamController) Stream() *StringStream {
	return &StringStream{sc.StreamController.Stream()}
}

type StringStream struct {
	*eventual2go.Stream
}

type StringSuscriber func(string)

func (l StringSuscriber) toSuscriber() eventual2go.Subscriber {
	return func(d eventual2go.Data) { l(d.(string)) }
}

func (s *StringStream) Listen(ss StringSuscriber) *eventual2go.Subscription {
	return s.Stream.Listen(ss.toSuscriber())
}

type StringFilter func(string) bool

func (f StringFilter) toFilter() eventual2go.Filter {
	return func(d eventual2go.Data) bool { return f(d.(string)) }
}

func (s *StringStream) Where(f StringFilter) *StringStream {
	return &StringStream{s.Stream.Where(f.toFilter())}
}

func (s *StringStream) WhereNot(f StringFilter) *StringStream {
	return &StringStream{s.Stream.WhereNot(f.toFilter())}
}

func (s *StringStream) First() *StringFuture {
	return &StringFuture{s.Stream.First()}
}

func (s *StringStream) FirstWhere(f StringFilter) *StringFuture {
	return &StringFuture{s.Stream.FirstWhere(f.toFilter())}
}

func (s *StringStream) FirstWhereNot(f StringFilter) *StringFuture {
	return &StringFuture{s.Stream.FirstWhereNot(f.toFilter())}
}

func (s *StringStream) AsChan() (c chan string) {
	c = make(chan string)
	s.Listen(pipeToStringChan(c)).Closed().Then(closeStringChan(c))
	return
}

func pipeToStringChan(c chan string) StringSuscriber {
	return func(d string) {
		c <- d
	}
}

func closeStringChan(c chan string) eventual2go.CompletionHandler {
	return func(d eventual2go.Data) eventual2go.Data {
		close(c)
		return nil
	}
}
